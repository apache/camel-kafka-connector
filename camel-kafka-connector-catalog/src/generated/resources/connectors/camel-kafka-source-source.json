{
	"connector": {
		"class": "org.apache.camel.kafkaconnector.kafkasource.CamelKafkasourceSourceConnector",
		"artifactId": "camel-kafka-source-kafka-connector",
		"groupId": "org.apache.camel.kafkaconnector",
		"id": "camel-kafka-source-source",
		"type": "source",
		"version": "4.18.0-SNAPSHOT",
		"description": "Receive data from Kafka topics."
	},
	"properties": {
		"camel.kamelet.kafka-source.topic": {
			"name": "camel.kamelet.kafka-source.topic",
			"description": "Comma separated list of Kafka topic names",
			"priority": "HIGH",
			"required": "true"
		},
		"camel.kamelet.kafka-source.bootstrapServers": {
			"name": "camel.kamelet.kafka-source.bootstrapServers",
			"description": "Comma separated list of Kafka Broker URLs",
			"priority": "HIGH",
			"required": "true"
		},
		"camel.kamelet.kafka-source.saslAuthType": {
			"name": "camel.kamelet.kafka-source.saslAuthType",
			"description": "Authentication type to use. Use NONE for no authentication, PLAIN or SCRAM_SHA_256\/SCRAM_SHA_512 for username\/password, SSL for certificate-based, OAUTH for OAuth 2.0, AWS_MSK_IAM for MSK, or KERBEROS for Kerberos.",
			"defaultValue": "\"NONE\"",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.saslUsername": {
			"name": "camel.kamelet.kafka-source.saslUsername",
			"description": "Username for SASL authentication. Required when saslAuthType is PLAIN, SCRAM_SHA_256, or SCRAM_SHA_512.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.saslPassword": {
			"name": "camel.kamelet.kafka-source.saslPassword",
			"description": "Password for SASL authentication. Required when saslAuthType is PLAIN, SCRAM_SHA_256, or SCRAM_SHA_512.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.oauthClientId": {
			"name": "camel.kamelet.kafka-source.oauthClientId",
			"description": "OAuth client ID. Required when saslAuthType is OAUTH.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.oauthClientSecret": {
			"name": "camel.kamelet.kafka-source.oauthClientSecret",
			"description": "OAuth client secret. Required when saslAuthType is OAUTH.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.oauthTokenEndpointUri": {
			"name": "camel.kamelet.kafka-source.oauthTokenEndpointUri",
			"description": "OAuth token endpoint URI. Required when saslAuthType is OAUTH.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.oauthScope": {
			"name": "camel.kamelet.kafka-source.oauthScope",
			"description": "OAuth scope. Optional when saslAuthType is OAUTH.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.sslTruststoreLocation": {
			"name": "camel.kamelet.kafka-source.sslTruststoreLocation",
			"description": "The location of the trust store file.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.sslTruststorePassword": {
			"name": "camel.kamelet.kafka-source.sslTruststorePassword",
			"description": "The password for the trust store file.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.sslKeystoreLocation": {
			"name": "camel.kamelet.kafka-source.sslKeystoreLocation",
			"description": "The location of the key store file. Used for mTLS authentication.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.sslKeystorePassword": {
			"name": "camel.kamelet.kafka-source.sslKeystorePassword",
			"description": "The password for the key store file.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.sslKeyPassword": {
			"name": "camel.kamelet.kafka-source.sslKeyPassword",
			"description": "The password of the private key in the key store file.",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.autoCommitEnable": {
			"name": "camel.kamelet.kafka-source.autoCommitEnable",
			"description": "If true, periodically commit to ZooKeeper the offset of messages already fetched by the consumer",
			"defaultValue": "true",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.allowManualCommit": {
			"name": "camel.kamelet.kafka-source.allowManualCommit",
			"description": "Whether to allow doing manual commits",
			"defaultValue": "false",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.pollOnError": {
			"name": "camel.kamelet.kafka-source.pollOnError",
			"description": "What to do if kafka threw an exception while polling for new messages. There are 5 enums and the value can be one of DISCARD, ERROR_HANDLER, RECONNECT, RETRY, STOP",
			"defaultValue": "\"ERROR_HANDLER\"",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.autoOffsetReset": {
			"name": "camel.kamelet.kafka-source.autoOffsetReset",
			"description": "What to do when there is no initial offset. There are 3 enums and the value can be one of latest, earliest, none",
			"defaultValue": "\"latest\"",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.consumerGroup": {
			"name": "camel.kamelet.kafka-source.consumerGroup",
			"description": "A string that uniquely identifies the group of consumers to which this source belongs Example: my-group-id",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.deserializeHeaders": {
			"name": "camel.kamelet.kafka-source.deserializeHeaders",
			"description": "When enabled the Kamelet source will deserialize all message headers to String representation.",
			"defaultValue": "true",
			"priority": "MEDIUM",
			"required": "false"
		},
		"camel.kamelet.kafka-source.topicIsPattern": {
			"name": "camel.kamelet.kafka-source.topicIsPattern",
			"description": "Whether the topic is a pattern (regular expression). This can be used to subscribe to dynamic number of topics matching the pattern.",
			"defaultValue": "false",
			"priority": "MEDIUM",
			"required": "false"
		}
	}
}