// kafka-connector options: START
[[camel-kafka-kafka-connector-source]]
= camel-kafka-kafka-connector source configuration

Connector description: Sent and receive messages to/from an Apache Kafka broker.

When using camel-kafka-kafka-connector as source make sure to use the following Maven dependency to have support for the connector:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.kafkaconnector</groupId>
  <artifactId>camel-kafka-kafka-connector</artifactId>
  <version>x.x.x</version>
  <!-- use the same version as your Camel Kafka connector version -->
</dependency>
----

To use this Source connector in Kafka connect you'll need to set the following connector.class

[source,java]
----
connector.class=org.apache.camel.kafkaconnector.kafka.CamelKafkaSourceConnector
----


The camel-kafka source connector supports 125 options, which are listed below.



[width="100%",cols="2,5,^1,1,1",options="header"]
|===
| Name | Description | Default | Required | Priority
| *camel.source.path.topic* | Name of the topic to use. On the consumer you can use comma to separate multiple topics. A producer can only send a message to a single topic. | null | true | HIGH
| *camel.source.endpoint.additionalProperties* | Sets additional properties for either kafka consumer or kafka producer in case they can't be set directly on the camel configurations (e.g: new Kafka properties that are not reflected yet in Camel configurations), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=\http://localhost:8811/avro | null | false | MEDIUM
| *camel.source.endpoint.brokers* | URL of the Kafka brokers to use. The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers. This option is known as bootstrap.servers in the Kafka documentation. | null | false | MEDIUM
| *camel.source.endpoint.clientId* | The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request. | null | false | MEDIUM
| *camel.source.endpoint.headerFilterStrategy* | To use a custom HeaderFilterStrategy to filter header to and from Camel message. | null | false | MEDIUM
| *camel.source.endpoint.reconnectBackoffMaxMs* | The maximum amount of time in milliseconds to wait when reconnecting to a broker that has repeatedly failed to connect. If provided, the backoff per host will increase exponentially for each consecutive connection failure, up to this maximum. After calculating the backoff increase, 20% random jitter is added to avoid connection storms. | "1000" | false | MEDIUM
| *camel.source.endpoint.shutdownTimeout* | Timeout in milli seconds to wait gracefully for the consumer or producer to shutdown and terminate its worker threads. | 30000 | false | MEDIUM
| *camel.source.endpoint.allowManualCommit* | Whether to allow doing manual commits via KafkaManualCommit. If this option is enabled then an instance of KafkaManualCommit is stored on the Exchange message header, which allows end users to access this API and perform manual offset commits via the Kafka consumer. | false | false | MEDIUM
| *camel.source.endpoint.autoCommitEnable* | If true, periodically commit to ZooKeeper the offset of messages already fetched by the consumer. This committed offset will be used when the process fails as the position from which the new consumer will begin. | "true" | false | MEDIUM
| *camel.source.endpoint.autoCommitIntervalMs* | The frequency in ms that the consumer offsets are committed to zookeeper. | "5000" | false | MEDIUM
| *camel.source.endpoint.autoCommitOnStop* | Whether to perform an explicit auto commit when the consumer stops to ensure the broker has a commit from the last consumed message. This requires the option autoCommitEnable is turned on. The possible values are: sync, async, or none. And sync is the default value. One of: [sync] [async] [none] | "sync" | false | MEDIUM
| *camel.source.endpoint.autoOffsetReset* | What to do when there is no initial offset in ZooKeeper or if an offset is out of range: earliest : automatically reset the offset to the earliest offset latest : automatically reset the offset to the latest offset fail: throw exception to the consumer One of: [latest] [earliest] [none] | "latest" | false | MEDIUM
| *camel.source.endpoint.breakOnFirstError* | This options controls what happens when a consumer is processing an exchange and it fails. If the option is false then the consumer continues to the next message and processes it. If the option is true then the consumer breaks out, and will seek back to offset of the message that caused a failure, and then re-attempt to process this message. However this can lead to endless processing of the same message if its bound to fail every time, eg a poison message. Therefore its recommended to deal with that for example by using Camel's error handler. | false | false | MEDIUM
| *camel.source.endpoint.bridgeErrorHandler* | Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored. | false | false | MEDIUM
| *camel.source.endpoint.checkCrcs* | Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance. | "true" | false | MEDIUM
| *camel.source.endpoint.consumerRequestTimeoutMs* | The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted. | "40000" | false | MEDIUM
| *camel.source.endpoint.consumersCount* | The number of consumers that connect to kafka server | 1 | false | MEDIUM
| *camel.source.endpoint.consumerStreams* | Number of concurrent consumers on the consumer | 10 | false | MEDIUM
| *camel.source.endpoint.fetchMaxBytes* | The maximum amount of data the server should return for a fetch request This is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that the consumer can make progress. The maximum message size accepted by the broker is defined via message.max.bytes (broker config) or max.message.bytes (topic config). Note that the consumer performs multiple fetches in parallel. | "52428800" | false | MEDIUM
| *camel.source.endpoint.fetchMinBytes* | The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request. | "1" | false | MEDIUM
| *camel.source.endpoint.fetchWaitMaxMs* | The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy fetch.min.bytes | "500" | false | MEDIUM
| *camel.source.endpoint.groupId* | A string that uniquely identifies the group of consumer processes to which this consumer belongs. By setting the same group id multiple processes indicate that they are all part of the same consumer group. This option is required for consumers. | null | false | MEDIUM
| *camel.source.endpoint.headerDeserializer* | To use a custom KafkaHeaderDeserializer to deserialize kafka headers values | null | false | MEDIUM
| *camel.source.endpoint.heartbeatIntervalMs* | The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. Heartbeats are used to ensure that the consumer's session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than session.timeout.ms, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances. | "3000" | false | MEDIUM
| *camel.source.endpoint.keyDeserializer* | Deserializer class for key that implements the Deserializer interface. | "org.apache.kafka.common.serialization.StringDeserializer" | false | MEDIUM
| *camel.source.endpoint.maxPartitionFetchBytes* | The maximum amount of data per-partition the server will return. The maximum total memory used for a request will be #partitions max.partition.fetch.bytes. This size must be at least as large as the maximum message size the server allows or else it is possible for the producer to send messages larger than the consumer can fetch. If that happens, the consumer can get stuck trying to fetch a large message on a certain partition. | "1048576" | false | MEDIUM
| *camel.source.endpoint.maxPollIntervalMs* | The maximum delay between invocations of poll() when using consumer group management. This places an upper bound on the amount of time that the consumer can be idle before fetching more records. If poll() is not called before expiration of this timeout, then the consumer is considered failed and the group will rebalance in order to reassign the partitions to another member. | null | false | MEDIUM
| *camel.source.endpoint.maxPollRecords* | The maximum number of records returned in a single call to poll() | "500" | false | MEDIUM
| *camel.source.endpoint.offsetRepository* | The offset repository to use in order to locally store the offset of each partition of the topic. Defining one will disable the autocommit. | null | false | MEDIUM
| *camel.source.endpoint.partitionAssignor* | The class name of the partition assignment strategy that the client will use to distribute partition ownership amongst consumer instances when group management is used | "org.apache.kafka.clients.consumer.RangeAssignor" | false | MEDIUM
| *camel.source.endpoint.pollOnError* | What to do if kafka threw an exception while polling for new messages. Will by default use the value from the component configuration unless an explicit value has been configured on the endpoint level. DISCARD will discard the message and continue to poll next message. ERROR_HANDLER will use Camel's error handler to process the exception, and afterwards continue to poll next message. RECONNECT will re-connect the consumer and try poll the message again RETRY will let the consumer retry polling the same message again STOP will stop the consumer (have to be manually started/restarted if the consumer should be able to consume messages again) One of: [DISCARD] [ERROR_HANDLER] [RECONNECT] [RETRY] [STOP] | "ERROR_HANDLER" | false | MEDIUM
| *camel.source.endpoint.pollTimeoutMs* | The timeout used when polling the KafkaConsumer. | "5000" | false | MEDIUM
| *camel.source.endpoint.seekTo* | Set if KafkaConsumer will read from beginning or end on startup: beginning : read from beginning end : read from end This is replacing the earlier property seekToBeginning One of: [beginning] [end] | null | false | MEDIUM
| *camel.source.endpoint.sessionTimeoutMs* | The timeout used to detect failures when using Kafka's group management facilities. | "10000" | false | MEDIUM
| *camel.source.endpoint.specificAvroReader* | This enables the use of a specific Avro reader for use with the Confluent Platform schema registry and the io.confluent.kafka.serializers.KafkaAvroDeserializer. This option is only available in the Confluent Platform (not standard Apache Kafka) | false | false | MEDIUM
| *camel.source.endpoint.topicIsPattern* | Whether the topic is a pattern (regular expression). This can be used to subscribe to dynamic number of topics matching the pattern. | false | false | MEDIUM
| *camel.source.endpoint.valueDeserializer* | Deserializer class for value that implements the Deserializer interface. | "org.apache.kafka.common.serialization.StringDeserializer" | false | MEDIUM
| *camel.source.endpoint.exceptionHandler* | To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored. | null | false | MEDIUM
| *camel.source.endpoint.exchangePattern* | Sets the exchange pattern when the consumer creates an exchange. One of: [InOnly] [InOut] [InOptionalOut] | null | false | MEDIUM
| *camel.source.endpoint.synchronous* | Sets whether synchronous processing should be strictly used | false | false | MEDIUM
| *camel.source.endpoint.schemaRegistryURL* | URL of the Confluent Platform schema registry servers to use. The format is host1:port1,host2:port2. This is known as schema.registry.url in the Confluent Platform documentation. This option is only available in the Confluent Platform (not standard Apache Kafka) | null | false | MEDIUM
| *camel.source.endpoint.interceptorClasses* | Sets interceptors for producer or consumers. Producer interceptors have to be classes implementing org.apache.kafka.clients.producer.ProducerInterceptor Consumer interceptors have to be classes implementing org.apache.kafka.clients.consumer.ConsumerInterceptor Note that if you use Producer interceptor on a consumer it will throw a class cast exception in runtime | null | false | MEDIUM
| *camel.source.endpoint.kerberosBeforeReloginMinTime* | Login thread sleep time between refresh attempts. | "60000" | false | MEDIUM
| *camel.source.endpoint.kerberosInitCmd* | Kerberos kinit command path. Default is /usr/bin/kinit | "/usr/bin/kinit" | false | MEDIUM
| *camel.source.endpoint.kerberosPrincipalToLocal Rules* | A list of rules for mapping from principal names to short names (typically operating system usernames). The rules are evaluated in order and the first rule that matches a principal name is used to map it to a short name. Any later rules in the list are ignored. By default, principal names of the form \{username}/\{hostname}\{REALM} are mapped to \{username}. For more details on the format please see the security authorization and acls documentation.. Multiple values can be separated by comma | "DEFAULT" | false | MEDIUM
| *camel.source.endpoint.kerberosRenewJitter* | Percentage of random jitter added to the renewal time. | "0.05" | false | MEDIUM
| *camel.source.endpoint.kerberosRenewWindowFactor* | Login thread will sleep until the specified window factor of time from last refresh to ticket's expiry has been reached, at which time it will try to renew the ticket. | "0.8" | false | MEDIUM
| *camel.source.endpoint.saslJaasConfig* | Expose the kafka sasl.jaas.config parameter Example: org.apache.kafka.common.security.plain.PlainLoginModule required username=USERNAME password=PASSWORD; | null | false | MEDIUM
| *camel.source.endpoint.saslKerberosServiceName* | The Kerberos principal name that Kafka runs as. This can be defined either in Kafka's JAAS config or in Kafka's config. | null | false | MEDIUM
| *camel.source.endpoint.saslMechanism* | The Simple Authentication and Security Layer (SASL) Mechanism used. For the valid values see \http://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml | "GSSAPI" | false | MEDIUM
| *camel.source.endpoint.securityProtocol* | Protocol used to communicate with brokers. SASL_PLAINTEXT, PLAINTEXT and SSL are supported | "PLAINTEXT" | false | MEDIUM
| *camel.source.endpoint.sslCipherSuites* | A list of cipher suites. This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol.By default all the available cipher suites are supported. | null | false | MEDIUM
| *camel.source.endpoint.sslContextParameters* | SSL configuration using a Camel SSLContextParameters object. If configured it's applied before the other SSL endpoint parameters. NOTE: Kafka only supports loading keystore from file locations, so prefix the location with file: in the KeyStoreParameters.resource option. | null | false | MEDIUM
| *camel.source.endpoint.sslEnabledProtocols* | The list of protocols enabled for SSL connections. TLSv1.2, TLSv1.1 and TLSv1 are enabled by default. | null | false | MEDIUM
| *camel.source.endpoint.sslEndpointAlgorithm* | The endpoint identification algorithm to validate server hostname using server certificate. | "https" | false | MEDIUM
| *camel.source.endpoint.sslKeymanagerAlgorithm* | The algorithm used by key manager factory for SSL connections. Default value is the key manager factory algorithm configured for the Java Virtual Machine. | "SunX509" | false | MEDIUM
| *camel.source.endpoint.sslKeystoreType* | The file format of the key store file. This is optional for client. Default value is JKS | "JKS" | false | MEDIUM
| *camel.source.endpoint.sslProtocol* | The SSL protocol used to generate the SSLContext. Default setting is TLS, which is fine for most cases. Allowed values in recent JVMs are TLS, TLSv1.1 and TLSv1.2. SSL, SSLv2 and SSLv3 may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities. | null | false | MEDIUM
| *camel.source.endpoint.sslProvider* | The name of the security provider used for SSL connections. Default value is the default security provider of the JVM. | null | false | MEDIUM
| *camel.source.endpoint.sslTrustmanagerAlgorithm* | The algorithm used by trust manager factory for SSL connections. Default value is the trust manager factory algorithm configured for the Java Virtual Machine. | "PKIX" | false | MEDIUM
| *camel.source.endpoint.sslTruststoreType* | The file format of the trust store file. Default value is JKS. | "JKS" | false | MEDIUM
| *camel.component.kafka.additionalProperties* | Sets additional properties for either kafka consumer or kafka producer in case they can't be set directly on the camel configurations (e.g: new Kafka properties that are not reflected yet in Camel configurations), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=\http://localhost:8811/avro | null | false | MEDIUM
| *camel.component.kafka.brokers* | URL of the Kafka brokers to use. The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers. This option is known as bootstrap.servers in the Kafka documentation. | null | false | MEDIUM
| *camel.component.kafka.clientId* | The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request. | null | false | MEDIUM
| *camel.component.kafka.configuration* | Allows to pre-configure the Kafka component with common options that the endpoints will reuse. | null | false | MEDIUM
| *camel.component.kafka.headerFilterStrategy* | To use a custom HeaderFilterStrategy to filter header to and from Camel message. | null | false | MEDIUM
| *camel.component.kafka.reconnectBackoffMaxMs* | The maximum amount of time in milliseconds to wait when reconnecting to a broker that has repeatedly failed to connect. If provided, the backoff per host will increase exponentially for each consecutive connection failure, up to this maximum. After calculating the backoff increase, 20% random jitter is added to avoid connection storms. | "1000" | false | MEDIUM
| *camel.component.kafka.shutdownTimeout* | Timeout in milli seconds to wait gracefully for the consumer or producer to shutdown and terminate its worker threads. | 30000 | false | MEDIUM
| *camel.component.kafka.allowManualCommit* | Whether to allow doing manual commits via KafkaManualCommit. If this option is enabled then an instance of KafkaManualCommit is stored on the Exchange message header, which allows end users to access this API and perform manual offset commits via the Kafka consumer. | false | false | MEDIUM
| *camel.component.kafka.autoCommitEnable* | If true, periodically commit to ZooKeeper the offset of messages already fetched by the consumer. This committed offset will be used when the process fails as the position from which the new consumer will begin. | "true" | false | MEDIUM
| *camel.component.kafka.autoCommitIntervalMs* | The frequency in ms that the consumer offsets are committed to zookeeper. | "5000" | false | MEDIUM
| *camel.component.kafka.autoCommitOnStop* | Whether to perform an explicit auto commit when the consumer stops to ensure the broker has a commit from the last consumed message. This requires the option autoCommitEnable is turned on. The possible values are: sync, async, or none. And sync is the default value. One of: [sync] [async] [none] | "sync" | false | MEDIUM
| *camel.component.kafka.autoOffsetReset* | What to do when there is no initial offset in ZooKeeper or if an offset is out of range: earliest : automatically reset the offset to the earliest offset latest : automatically reset the offset to the latest offset fail: throw exception to the consumer One of: [latest] [earliest] [none] | "latest" | false | MEDIUM
| *camel.component.kafka.breakOnFirstError* | This options controls what happens when a consumer is processing an exchange and it fails. If the option is false then the consumer continues to the next message and processes it. If the option is true then the consumer breaks out, and will seek back to offset of the message that caused a failure, and then re-attempt to process this message. However this can lead to endless processing of the same message if its bound to fail every time, eg a poison message. Therefore its recommended to deal with that for example by using Camel's error handler. | false | false | MEDIUM
| *camel.component.kafka.bridgeErrorHandler* | Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored. | false | false | MEDIUM
| *camel.component.kafka.checkCrcs* | Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance. | "true" | false | MEDIUM
| *camel.component.kafka.consumerRequestTimeoutMs* | The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted. | "40000" | false | MEDIUM
| *camel.component.kafka.consumersCount* | The number of consumers that connect to kafka server | 1 | false | MEDIUM
| *camel.component.kafka.consumerStreams* | Number of concurrent consumers on the consumer | 10 | false | MEDIUM
| *camel.component.kafka.fetchMaxBytes* | The maximum amount of data the server should return for a fetch request This is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that the consumer can make progress. The maximum message size accepted by the broker is defined via message.max.bytes (broker config) or max.message.bytes (topic config). Note that the consumer performs multiple fetches in parallel. | "52428800" | false | MEDIUM
| *camel.component.kafka.fetchMinBytes* | The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request. | "1" | false | MEDIUM
| *camel.component.kafka.fetchWaitMaxMs* | The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy fetch.min.bytes | "500" | false | MEDIUM
| *camel.component.kafka.groupId* | A string that uniquely identifies the group of consumer processes to which this consumer belongs. By setting the same group id multiple processes indicate that they are all part of the same consumer group. This option is required for consumers. | null | false | MEDIUM
| *camel.component.kafka.headerDeserializer* | To use a custom KafkaHeaderDeserializer to deserialize kafka headers values | null | false | MEDIUM
| *camel.component.kafka.heartbeatIntervalMs* | The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. Heartbeats are used to ensure that the consumer's session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than session.timeout.ms, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances. | "3000" | false | MEDIUM
| *camel.component.kafka.keyDeserializer* | Deserializer class for key that implements the Deserializer interface. | "org.apache.kafka.common.serialization.StringDeserializer" | false | MEDIUM
| *camel.component.kafka.maxPartitionFetchBytes* | The maximum amount of data per-partition the server will return. The maximum total memory used for a request will be #partitions max.partition.fetch.bytes. This size must be at least as large as the maximum message size the server allows or else it is possible for the producer to send messages larger than the consumer can fetch. If that happens, the consumer can get stuck trying to fetch a large message on a certain partition. | "1048576" | false | MEDIUM
| *camel.component.kafka.maxPollIntervalMs* | The maximum delay between invocations of poll() when using consumer group management. This places an upper bound on the amount of time that the consumer can be idle before fetching more records. If poll() is not called before expiration of this timeout, then the consumer is considered failed and the group will rebalance in order to reassign the partitions to another member. | null | false | MEDIUM
| *camel.component.kafka.maxPollRecords* | The maximum number of records returned in a single call to poll() | "500" | false | MEDIUM
| *camel.component.kafka.offsetRepository* | The offset repository to use in order to locally store the offset of each partition of the topic. Defining one will disable the autocommit. | null | false | MEDIUM
| *camel.component.kafka.partitionAssignor* | The class name of the partition assignment strategy that the client will use to distribute partition ownership amongst consumer instances when group management is used | "org.apache.kafka.clients.consumer.RangeAssignor" | false | MEDIUM
| *camel.component.kafka.pollOnError* | What to do if kafka threw an exception while polling for new messages. Will by default use the value from the component configuration unless an explicit value has been configured on the endpoint level. DISCARD will discard the message and continue to poll next message. ERROR_HANDLER will use Camel's error handler to process the exception, and afterwards continue to poll next message. RECONNECT will re-connect the consumer and try poll the message again RETRY will let the consumer retry polling the same message again STOP will stop the consumer (have to be manually started/restarted if the consumer should be able to consume messages again) One of: [DISCARD] [ERROR_HANDLER] [RECONNECT] [RETRY] [STOP] | "ERROR_HANDLER" | false | MEDIUM
| *camel.component.kafka.pollTimeoutMs* | The timeout used when polling the KafkaConsumer. | "5000" | false | MEDIUM
| *camel.component.kafka.seekTo* | Set if KafkaConsumer will read from beginning or end on startup: beginning : read from beginning end : read from end This is replacing the earlier property seekToBeginning One of: [beginning] [end] | null | false | MEDIUM
| *camel.component.kafka.sessionTimeoutMs* | The timeout used to detect failures when using Kafka's group management facilities. | "10000" | false | MEDIUM
| *camel.component.kafka.specificAvroReader* | This enables the use of a specific Avro reader for use with the Confluent Platform schema registry and the io.confluent.kafka.serializers.KafkaAvroDeserializer. This option is only available in the Confluent Platform (not standard Apache Kafka) | false | false | MEDIUM
| *camel.component.kafka.topicIsPattern* | Whether the topic is a pattern (regular expression). This can be used to subscribe to dynamic number of topics matching the pattern. | false | false | MEDIUM
| *camel.component.kafka.valueDeserializer* | Deserializer class for value that implements the Deserializer interface. | "org.apache.kafka.common.serialization.StringDeserializer" | false | MEDIUM
| *camel.component.kafka.kafkaManualCommitFactory* | Factory to use for creating KafkaManualCommit instances. This allows to plugin a custom factory to create custom KafkaManualCommit instances in case special logic is needed when doing manual commits that deviates from the default implementation that comes out of the box. | null | false | MEDIUM
| *camel.component.kafka.pollExceptionStrategy* | To use a custom strategy with the consumer to control how to handle exceptions thrown from the Kafka broker while pooling messages. | null | false | MEDIUM
| *camel.component.kafka.autowiredEnabled* | Whether autowiring is enabled. This is used for automatic autowiring options (the option must be marked as autowired) by looking up in the registry to find if there is a single instance of matching type, which then gets configured on the component. This can be used for automatic configuring JDBC data sources, JMS connection factories, AWS Clients, etc. | true | false | MEDIUM
| *camel.component.kafka.kafkaClientFactory* | Factory to use for creating org.apache.kafka.clients.consumer.KafkaConsumer and org.apache.kafka.clients.producer.KafkaProducer instances. This allows to configure a custom factory to create instances with logic that extends the vanilla Kafka clients. | null | false | MEDIUM
| *camel.component.kafka.synchronous* | Sets whether synchronous processing should be strictly used | false | false | MEDIUM
| *camel.component.kafka.schemaRegistryURL* | URL of the Confluent Platform schema registry servers to use. The format is host1:port1,host2:port2. This is known as schema.registry.url in the Confluent Platform documentation. This option is only available in the Confluent Platform (not standard Apache Kafka) | null | false | MEDIUM
| *camel.component.kafka.interceptorClasses* | Sets interceptors for producer or consumers. Producer interceptors have to be classes implementing org.apache.kafka.clients.producer.ProducerInterceptor Consumer interceptors have to be classes implementing org.apache.kafka.clients.consumer.ConsumerInterceptor Note that if you use Producer interceptor on a consumer it will throw a class cast exception in runtime | null | false | MEDIUM
| *camel.component.kafka.kerberosBeforeReloginMinTime* | Login thread sleep time between refresh attempts. | "60000" | false | MEDIUM
| *camel.component.kafka.kerberosInitCmd* | Kerberos kinit command path. Default is /usr/bin/kinit | "/usr/bin/kinit" | false | MEDIUM
| *camel.component.kafka.kerberosPrincipalToLocal Rules* | A list of rules for mapping from principal names to short names (typically operating system usernames). The rules are evaluated in order and the first rule that matches a principal name is used to map it to a short name. Any later rules in the list are ignored. By default, principal names of the form \{username}/\{hostname}\{REALM} are mapped to \{username}. For more details on the format please see the security authorization and acls documentation.. Multiple values can be separated by comma | "DEFAULT" | false | MEDIUM
| *camel.component.kafka.kerberosRenewJitter* | Percentage of random jitter added to the renewal time. | "0.05" | false | MEDIUM
| *camel.component.kafka.kerberosRenewWindowFactor* | Login thread will sleep until the specified window factor of time from last refresh to ticket's expiry has been reached, at which time it will try to renew the ticket. | "0.8" | false | MEDIUM
| *camel.component.kafka.saslJaasConfig* | Expose the kafka sasl.jaas.config parameter Example: org.apache.kafka.common.security.plain.PlainLoginModule required username=USERNAME password=PASSWORD; | null | false | MEDIUM
| *camel.component.kafka.saslKerberosServiceName* | The Kerberos principal name that Kafka runs as. This can be defined either in Kafka's JAAS config or in Kafka's config. | null | false | MEDIUM
| *camel.component.kafka.saslMechanism* | The Simple Authentication and Security Layer (SASL) Mechanism used. For the valid values see \http://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml | "GSSAPI" | false | MEDIUM
| *camel.component.kafka.securityProtocol* | Protocol used to communicate with brokers. SASL_PLAINTEXT, PLAINTEXT and SSL are supported | "PLAINTEXT" | false | MEDIUM
| *camel.component.kafka.sslCipherSuites* | A list of cipher suites. This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol.By default all the available cipher suites are supported. | null | false | MEDIUM
| *camel.component.kafka.sslContextParameters* | SSL configuration using a Camel SSLContextParameters object. If configured it's applied before the other SSL endpoint parameters. NOTE: Kafka only supports loading keystore from file locations, so prefix the location with file: in the KeyStoreParameters.resource option. | null | false | MEDIUM
| *camel.component.kafka.sslEnabledProtocols* | The list of protocols enabled for SSL connections. TLSv1.2, TLSv1.1 and TLSv1 are enabled by default. | null | false | MEDIUM
| *camel.component.kafka.sslEndpointAlgorithm* | The endpoint identification algorithm to validate server hostname using server certificate. | "https" | false | MEDIUM
| *camel.component.kafka.sslKeymanagerAlgorithm* | The algorithm used by key manager factory for SSL connections. Default value is the key manager factory algorithm configured for the Java Virtual Machine. | "SunX509" | false | MEDIUM
| *camel.component.kafka.sslKeystoreType* | The file format of the key store file. This is optional for client. Default value is JKS | "JKS" | false | MEDIUM
| *camel.component.kafka.sslProtocol* | The SSL protocol used to generate the SSLContext. Default setting is TLS, which is fine for most cases. Allowed values in recent JVMs are TLS, TLSv1.1 and TLSv1.2. SSL, SSLv2 and SSLv3 may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities. | null | false | MEDIUM
| *camel.component.kafka.sslProvider* | The name of the security provider used for SSL connections. Default value is the default security provider of the JVM. | null | false | MEDIUM
| *camel.component.kafka.sslTrustmanagerAlgorithm* | The algorithm used by trust manager factory for SSL connections. Default value is the trust manager factory algorithm configured for the Java Virtual Machine. | "PKIX" | false | MEDIUM
| *camel.component.kafka.sslTruststoreType* | The file format of the trust store file. Default value is JKS. | "JKS" | false | MEDIUM
| *camel.component.kafka.useGlobalSslContext Parameters* | Enable usage of global SSL context parameters. | false | false | MEDIUM
|===



The camel-kafka source connector has no converters out of the box.





The camel-kafka source connector has no transforms out of the box.





The camel-kafka source connector has no aggregation strategies out of the box.
// kafka-connector options: END
