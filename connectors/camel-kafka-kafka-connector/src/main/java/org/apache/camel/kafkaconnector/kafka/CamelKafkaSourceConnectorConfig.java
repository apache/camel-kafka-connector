/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.kafkaconnector.kafka;

import java.util.Map;
import javax.annotation.Generated;
import org.apache.camel.kafkaconnector.CamelSourceConnectorConfig;
import org.apache.kafka.common.config.ConfigDef;

@Generated("This class has been generated by camel-kafka-connector-generator-maven-plugin, remove this annotation to prevent it from being generated.")
public class CamelKafkaSourceConnectorConfig
        extends
            CamelSourceConnectorConfig {

    public static final String CAMEL_SOURCE_KAFKA_PATH_TOPIC_CONF = "camel.source.path.topic";
    public static final String CAMEL_SOURCE_KAFKA_PATH_TOPIC_DOC = "Name of the topic to use. On the consumer you can use comma to separate multiple topics. A producer can only send a message to a single topic.";
    public static final String CAMEL_SOURCE_KAFKA_PATH_TOPIC_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_ADDITIONAL_PROPERTIES_CONF = "camel.source.endpoint.additionalProperties";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_ADDITIONAL_PROPERTIES_DOC = "Sets additional properties for either kafka consumer or kafka producer in case they can't be set directly on the camel configurations (e.g: new Kafka properties that are not reflected yet in Camel configurations), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_ADDITIONAL_PROPERTIES_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_BROKERS_CONF = "camel.source.endpoint.brokers";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_BROKERS_DOC = "URL of the Kafka brokers to use. The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers. This option is known as bootstrap.servers in the Kafka documentation.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_BROKERS_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CLIENT_ID_CONF = "camel.source.endpoint.clientId";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CLIENT_ID_DOC = "The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CLIENT_ID_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_HEADER_FILTER_STRATEGY_CONF = "camel.source.endpoint.headerFilterStrategy";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_HEADER_FILTER_STRATEGY_DOC = "To use a custom HeaderFilterStrategy to filter header to and from Camel message.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_HEADER_FILTER_STRATEGY_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_RECONNECT_BACKOFF_MAX_MS_CONF = "camel.source.endpoint.reconnectBackoffMaxMs";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_RECONNECT_BACKOFF_MAX_MS_DOC = "The maximum amount of time in milliseconds to wait when reconnecting to a broker that has repeatedly failed to connect. If provided, the backoff per host will increase exponentially for each consecutive connection failure, up to this maximum. After calculating the backoff increase, 20% random jitter is added to avoid connection storms.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_RECONNECT_BACKOFF_MAX_MS_DEFAULT = "1000";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SHUTDOWN_TIMEOUT_CONF = "camel.source.endpoint.shutdownTimeout";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SHUTDOWN_TIMEOUT_DOC = "Timeout in milli seconds to wait gracefully for the consumer or producer to shutdown and terminate its worker threads.";
    public static final Integer CAMEL_SOURCE_KAFKA_ENDPOINT_SHUTDOWN_TIMEOUT_DEFAULT = 30000;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_ALLOW_MANUAL_COMMIT_CONF = "camel.source.endpoint.allowManualCommit";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_ALLOW_MANUAL_COMMIT_DOC = "Whether to allow doing manual commits via KafkaManualCommit. If this option is enabled then an instance of KafkaManualCommit is stored on the Exchange message header, which allows end users to access this API and perform manual offset commits via the Kafka consumer.";
    public static final Boolean CAMEL_SOURCE_KAFKA_ENDPOINT_ALLOW_MANUAL_COMMIT_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ENABLE_CONF = "camel.source.endpoint.autoCommitEnable";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ENABLE_DOC = "If true, periodically commit to ZooKeeper the offset of messages already fetched by the consumer. This committed offset will be used when the process fails as the position from which the new consumer will begin.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ENABLE_DEFAULT = "true";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_INTERVAL_MS_CONF = "camel.source.endpoint.autoCommitIntervalMs";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_INTERVAL_MS_DOC = "The frequency in ms that the consumer offsets are committed to zookeeper.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_INTERVAL_MS_DEFAULT = "5000";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ON_STOP_CONF = "camel.source.endpoint.autoCommitOnStop";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ON_STOP_DOC = "Whether to perform an explicit auto commit when the consumer stops to ensure the broker has a commit from the last consumed message. This requires the option autoCommitEnable is turned on. The possible values are: sync, async, or none. And sync is the default value. One of: [sync] [async] [none]";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ON_STOP_DEFAULT = "sync";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_OFFSET_RESET_CONF = "camel.source.endpoint.autoOffsetReset";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_OFFSET_RESET_DOC = "What to do when there is no initial offset in ZooKeeper or if an offset is out of range: earliest : automatically reset the offset to the earliest offset latest : automatically reset the offset to the latest offset fail: throw exception to the consumer One of: [latest] [earliest] [none]";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_OFFSET_RESET_DEFAULT = "latest";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_BREAK_ON_FIRST_ERROR_CONF = "camel.source.endpoint.breakOnFirstError";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_BREAK_ON_FIRST_ERROR_DOC = "This options controls what happens when a consumer is processing an exchange and it fails. If the option is false then the consumer continues to the next message and processes it. If the option is true then the consumer breaks out, and will seek back to offset of the message that caused a failure, and then re-attempt to process this message. However this can lead to endless processing of the same message if its bound to fail every time, eg a poison message. Therefore its recommended to deal with that for example by using Camel's error handler.";
    public static final Boolean CAMEL_SOURCE_KAFKA_ENDPOINT_BREAK_ON_FIRST_ERROR_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_BRIDGE_ERROR_HANDLER_CONF = "camel.source.endpoint.bridgeErrorHandler";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_BRIDGE_ERROR_HANDLER_DOC = "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.";
    public static final Boolean CAMEL_SOURCE_KAFKA_ENDPOINT_BRIDGE_ERROR_HANDLER_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CHECK_CRCS_CONF = "camel.source.endpoint.checkCrcs";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CHECK_CRCS_DOC = "Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CHECK_CRCS_DEFAULT = "true";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_REQUEST_TIMEOUT_MS_CONF = "camel.source.endpoint.consumerRequestTimeoutMs";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_REQUEST_TIMEOUT_MS_DOC = "The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_REQUEST_TIMEOUT_MS_DEFAULT = "40000";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMERS_COUNT_CONF = "camel.source.endpoint.consumersCount";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMERS_COUNT_DOC = "The number of consumers that connect to kafka server";
    public static final Integer CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMERS_COUNT_DEFAULT = 1;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_STREAMS_CONF = "camel.source.endpoint.consumerStreams";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_STREAMS_DOC = "Number of concurrent consumers on the consumer";
    public static final Integer CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_STREAMS_DEFAULT = 10;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MAX_BYTES_CONF = "camel.source.endpoint.fetchMaxBytes";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MAX_BYTES_DOC = "The maximum amount of data the server should return for a fetch request This is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that the consumer can make progress. The maximum message size accepted by the broker is defined via message.max.bytes (broker config) or max.message.bytes (topic config). Note that the consumer performs multiple fetches in parallel.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MAX_BYTES_DEFAULT = "52428800";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MIN_BYTES_CONF = "camel.source.endpoint.fetchMinBytes";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MIN_BYTES_DOC = "The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MIN_BYTES_DEFAULT = "1";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_WAIT_MAX_MS_CONF = "camel.source.endpoint.fetchWaitMaxMs";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_WAIT_MAX_MS_DOC = "The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy fetch.min.bytes";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_WAIT_MAX_MS_DEFAULT = "500";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_GROUP_ID_CONF = "camel.source.endpoint.groupId";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_GROUP_ID_DOC = "A string that uniquely identifies the group of consumer processes to which this consumer belongs. By setting the same group id multiple processes indicate that they are all part of the same consumer group. This option is required for consumers.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_GROUP_ID_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_HEARTBEAT_INTERVAL_MS_CONF = "camel.source.endpoint.heartbeatIntervalMs";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_HEARTBEAT_INTERVAL_MS_DOC = "The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. Heartbeats are used to ensure that the consumer's session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than session.timeout.ms, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_HEARTBEAT_INTERVAL_MS_DEFAULT = "3000";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KAFKA_HEADER_DESERIALIZER_CONF = "camel.source.endpoint.kafkaHeaderDeserializer";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KAFKA_HEADER_DESERIALIZER_DOC = "To use a custom KafkaHeaderDeserializer to deserialize kafka headers values";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KAFKA_HEADER_DESERIALIZER_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KEY_DESERIALIZER_CONF = "camel.source.endpoint.keyDeserializer";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KEY_DESERIALIZER_DOC = "Deserializer class for key that implements the Deserializer interface.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KEY_DESERIALIZER_DEFAULT = "org.apache.kafka.common.serialization.StringDeserializer";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_PARTITION_FETCH_BYTES_CONF = "camel.source.endpoint.maxPartitionFetchBytes";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_PARTITION_FETCH_BYTES_DOC = "The maximum amount of data per-partition the server will return. The maximum total memory used for a request will be #partitions max.partition.fetch.bytes. This size must be at least as large as the maximum message size the server allows or else it is possible for the producer to send messages larger than the consumer can fetch. If that happens, the consumer can get stuck trying to fetch a large message on a certain partition.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_PARTITION_FETCH_BYTES_DEFAULT = "1048576";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_INTERVAL_MS_CONF = "camel.source.endpoint.maxPollIntervalMs";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_INTERVAL_MS_DOC = "The maximum delay between invocations of poll() when using consumer group management. This places an upper bound on the amount of time that the consumer can be idle before fetching more records. If poll() is not called before expiration of this timeout, then the consumer is considered failed and the group will rebalance in order to reassign the partitions to another member.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_INTERVAL_MS_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_RECORDS_CONF = "camel.source.endpoint.maxPollRecords";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_RECORDS_DOC = "The maximum number of records returned in a single call to poll()";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_RECORDS_DEFAULT = "500";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_OFFSET_REPOSITORY_CONF = "camel.source.endpoint.offsetRepository";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_OFFSET_REPOSITORY_DOC = "The offset repository to use in order to locally store the offset of each partition of the topic. Defining one will disable the autocommit.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_OFFSET_REPOSITORY_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_PARTITION_ASSIGNOR_CONF = "camel.source.endpoint.partitionAssignor";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_PARTITION_ASSIGNOR_DOC = "The class name of the partition assignment strategy that the client will use to distribute partition ownership amongst consumer instances when group management is used";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_PARTITION_ASSIGNOR_DEFAULT = "org.apache.kafka.clients.consumer.RangeAssignor";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_POLL_TIMEOUT_MS_CONF = "camel.source.endpoint.pollTimeoutMs";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_POLL_TIMEOUT_MS_DOC = "The timeout used when polling the KafkaConsumer.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_POLL_TIMEOUT_MS_DEFAULT = "5000";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SEEK_TO_CONF = "camel.source.endpoint.seekTo";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SEEK_TO_DOC = "Set if KafkaConsumer will read from beginning or end on startup: beginning : read from beginning end : read from end This is replacing the earlier property seekToBeginning One of: [beginning] [end]";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SEEK_TO_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SESSION_TIMEOUT_MS_CONF = "camel.source.endpoint.sessionTimeoutMs";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SESSION_TIMEOUT_MS_DOC = "The timeout used to detect failures when using Kafka's group management facilities.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SESSION_TIMEOUT_MS_DEFAULT = "10000";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SPECIFIC_AVRO_READER_CONF = "camel.source.endpoint.specificAvroReader";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SPECIFIC_AVRO_READER_DOC = "This enables the use of a specific Avro reader for use with the Confluent Platform schema registry and the io.confluent.kafka.serializers.KafkaAvroDeserializer. This option is only available in the Confluent Platform (not standard Apache Kafka)";
    public static final Boolean CAMEL_SOURCE_KAFKA_ENDPOINT_SPECIFIC_AVRO_READER_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_TOPIC_IS_PATTERN_CONF = "camel.source.endpoint.topicIsPattern";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_TOPIC_IS_PATTERN_DOC = "Whether the topic is a pattern (regular expression). This can be used to subscribe to dynamic number of topics matching the pattern.";
    public static final Boolean CAMEL_SOURCE_KAFKA_ENDPOINT_TOPIC_IS_PATTERN_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_VALUE_DESERIALIZER_CONF = "camel.source.endpoint.valueDeserializer";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_VALUE_DESERIALIZER_DOC = "Deserializer class for value that implements the Deserializer interface.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_VALUE_DESERIALIZER_DEFAULT = "org.apache.kafka.common.serialization.StringDeserializer";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_EXCEPTION_HANDLER_CONF = "camel.source.endpoint.exceptionHandler";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_EXCEPTION_HANDLER_DOC = "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_EXCEPTION_HANDLER_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_EXCHANGE_PATTERN_CONF = "camel.source.endpoint.exchangePattern";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_EXCHANGE_PATTERN_DOC = "Sets the exchange pattern when the consumer creates an exchange. One of: [InOnly] [InOut] [InOptionalOut]";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_EXCHANGE_PATTERN_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_BASIC_PROPERTY_BINDING_CONF = "camel.source.endpoint.basicPropertyBinding";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_BASIC_PROPERTY_BINDING_DOC = "Whether the endpoint should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities";
    public static final Boolean CAMEL_SOURCE_KAFKA_ENDPOINT_BASIC_PROPERTY_BINDING_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SYNCHRONOUS_CONF = "camel.source.endpoint.synchronous";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SYNCHRONOUS_DOC = "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).";
    public static final Boolean CAMEL_SOURCE_KAFKA_ENDPOINT_SYNCHRONOUS_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SCHEMA_REGISTRY_URLCONF = "camel.source.endpoint.schemaRegistryURL";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SCHEMA_REGISTRY_URLDOC = "URL of the Confluent Platform schema registry servers to use. The format is host1:port1,host2:port2. This is known as schema.registry.url in the Confluent Platform documentation. This option is only available in the Confluent Platform (not standard Apache Kafka)";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SCHEMA_REGISTRY_URLDEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_INTERCEPTOR_CLASSES_CONF = "camel.source.endpoint.interceptorClasses";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_INTERCEPTOR_CLASSES_DOC = "Sets interceptors for producer or consumers. Producer interceptors have to be classes implementing org.apache.kafka.clients.producer.ProducerInterceptor Consumer interceptors have to be classes implementing org.apache.kafka.clients.consumer.ConsumerInterceptor Note that if you use Producer interceptor on a consumer it will throw a class cast exception in runtime";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_INTERCEPTOR_CLASSES_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_CONF = "camel.source.endpoint.kerberosBeforeReloginMinTime";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_DOC = "Login thread sleep time between refresh attempts.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_DEFAULT = "60000";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_INIT_CMD_CONF = "camel.source.endpoint.kerberosInitCmd";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_INIT_CMD_DOC = "Kerberos kinit command path. Default is /usr/bin/kinit";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_INIT_CMD_DEFAULT = "/usr/bin/kinit";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_CONF = "camel.source.endpoint.kerberosPrincipalToLocalRules";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DOC = "A list of rules for mapping from principal names to short names (typically operating system usernames). The rules are evaluated in order and the first rule that matches a principal name is used to map it to a short name. Any later rules in the list are ignored. By default, principal names of the form {username}/{hostname}{REALM} are mapped to {username}. For more details on the format please see the security authorization and acls documentation.. Multiple values can be separated by comma";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DEFAULT = "DEFAULT";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_JITTER_CONF = "camel.source.endpoint.kerberosRenewJitter";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_JITTER_DOC = "Percentage of random jitter added to the renewal time.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_JITTER_DEFAULT = "0.05";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_WINDOW_FACTOR_CONF = "camel.source.endpoint.kerberosRenewWindowFactor";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_WINDOW_FACTOR_DOC = "Login thread will sleep until the specified window factor of time from last refresh to ticket's expiry has been reached, at which time it will try to renew the ticket.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_WINDOW_FACTOR_DEFAULT = "0.8";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_JAAS_CONFIG_CONF = "camel.source.endpoint.saslJaasConfig";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_JAAS_CONFIG_DOC = "Expose the kafka sasl.jaas.config parameter Example: org.apache.kafka.common.security.plain.PlainLoginModule required username=USERNAME password=PASSWORD;";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_JAAS_CONFIG_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_KERBEROS_SERVICE_NAME_CONF = "camel.source.endpoint.saslKerberosServiceName";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_KERBEROS_SERVICE_NAME_DOC = "The Kerberos principal name that Kafka runs as. This can be defined either in Kafka's JAAS config or in Kafka's config.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_KERBEROS_SERVICE_NAME_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_MECHANISM_CONF = "camel.source.endpoint.saslMechanism";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_MECHANISM_DOC = "The Simple Authentication and Security Layer (SASL) Mechanism used. For the valid values see http://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_MECHANISM_DEFAULT = "GSSAPI";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SECURITY_PROTOCOL_CONF = "camel.source.endpoint.securityProtocol";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SECURITY_PROTOCOL_DOC = "Protocol used to communicate with brokers. SASL_PLAINTEXT, PLAINTEXT and SSL are supported";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SECURITY_PROTOCOL_DEFAULT = "PLAINTEXT";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CIPHER_SUITES_CONF = "camel.source.endpoint.sslCipherSuites";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CIPHER_SUITES_DOC = "A list of cipher suites. This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol.By default all the available cipher suites are supported.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CIPHER_SUITES_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CONTEXT_PARAMETERS_CONF = "camel.source.endpoint.sslContextParameters";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CONTEXT_PARAMETERS_DOC = "SSL configuration using a Camel SSLContextParameters object. If configured it's applied before the other SSL endpoint parameters. NOTE: Kafka only supports loading keystore from file locations, so prefix the location with file: in the KeyStoreParameters.resource option.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CONTEXT_PARAMETERS_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENABLED_PROTOCOLS_CONF = "camel.source.endpoint.sslEnabledProtocols";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENABLED_PROTOCOLS_DOC = "The list of protocols enabled for SSL connections. TLSv1.2, TLSv1.1 and TLSv1 are enabled by default.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENABLED_PROTOCOLS_DEFAULT = "TLSv1.2";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENDPOINT_ALGORITHM_CONF = "camel.source.endpoint.sslEndpointAlgorithm";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENDPOINT_ALGORITHM_DOC = "The endpoint identification algorithm to validate server hostname using server certificate.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENDPOINT_ALGORITHM_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYMANAGER_ALGORITHM_CONF = "camel.source.endpoint.sslKeymanagerAlgorithm";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYMANAGER_ALGORITHM_DOC = "The algorithm used by key manager factory for SSL connections. Default value is the key manager factory algorithm configured for the Java Virtual Machine.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYMANAGER_ALGORITHM_DEFAULT = "SunX509";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYSTORE_TYPE_CONF = "camel.source.endpoint.sslKeystoreType";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYSTORE_TYPE_DOC = "The file format of the key store file. This is optional for client. Default value is JKS";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYSTORE_TYPE_DEFAULT = "JKS";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROTOCOL_CONF = "camel.source.endpoint.sslProtocol";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROTOCOL_DOC = "The SSL protocol used to generate the SSLContext. Default setting is TLS, which is fine for most cases. Allowed values in recent JVMs are TLS, TLSv1.1 and TLSv1.2. SSL, SSLv2 and SSLv3 may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROTOCOL_DEFAULT = "TLSv1.2";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROVIDER_CONF = "camel.source.endpoint.sslProvider";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROVIDER_DOC = "The name of the security provider used for SSL connections. Default value is the default security provider of the JVM.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROVIDER_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTMANAGER_ALGORITHM_CONF = "camel.source.endpoint.sslTrustmanagerAlgorithm";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTMANAGER_ALGORITHM_DOC = "The algorithm used by trust manager factory for SSL connections. Default value is the trust manager factory algorithm configured for the Java Virtual Machine.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTMANAGER_ALGORITHM_DEFAULT = "PKIX";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTSTORE_TYPE_CONF = "camel.source.endpoint.sslTruststoreType";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTSTORE_TYPE_DOC = "The file format of the trust store file. Default value is JKS.";
    public static final String CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTSTORE_TYPE_DEFAULT = "JKS";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_ADDITIONAL_PROPERTIES_CONF = "camel.component.kafka.additionalProperties";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_ADDITIONAL_PROPERTIES_DOC = "Sets additional properties for either kafka consumer or kafka producer in case they can't be set directly on the camel configurations (e.g: new Kafka properties that are not reflected yet in Camel configurations), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_ADDITIONAL_PROPERTIES_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_BROKERS_CONF = "camel.component.kafka.brokers";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_BROKERS_DOC = "URL of the Kafka brokers to use. The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers. This option is known as bootstrap.servers in the Kafka documentation.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_BROKERS_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CLIENT_ID_CONF = "camel.component.kafka.clientId";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CLIENT_ID_DOC = "The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CLIENT_ID_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CONFIGURATION_CONF = "camel.component.kafka.configuration";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CONFIGURATION_DOC = "Allows to pre-configure the Kafka component with common options that the endpoints will reuse.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CONFIGURATION_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_HEADER_FILTER_STRATEGY_CONF = "camel.component.kafka.headerFilterStrategy";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_HEADER_FILTER_STRATEGY_DOC = "To use a custom HeaderFilterStrategy to filter header to and from Camel message.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_HEADER_FILTER_STRATEGY_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_RECONNECT_BACKOFF_MAX_MS_CONF = "camel.component.kafka.reconnectBackoffMaxMs";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_RECONNECT_BACKOFF_MAX_MS_DOC = "The maximum amount of time in milliseconds to wait when reconnecting to a broker that has repeatedly failed to connect. If provided, the backoff per host will increase exponentially for each consecutive connection failure, up to this maximum. After calculating the backoff increase, 20% random jitter is added to avoid connection storms.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_RECONNECT_BACKOFF_MAX_MS_DEFAULT = "1000";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SHUTDOWN_TIMEOUT_CONF = "camel.component.kafka.shutdownTimeout";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SHUTDOWN_TIMEOUT_DOC = "Timeout in milli seconds to wait gracefully for the consumer or producer to shutdown and terminate its worker threads.";
    public static final Integer CAMEL_SOURCE_KAFKA_COMPONENT_SHUTDOWN_TIMEOUT_DEFAULT = 30000;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_ALLOW_MANUAL_COMMIT_CONF = "camel.component.kafka.allowManualCommit";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_ALLOW_MANUAL_COMMIT_DOC = "Whether to allow doing manual commits via KafkaManualCommit. If this option is enabled then an instance of KafkaManualCommit is stored on the Exchange message header, which allows end users to access this API and perform manual offset commits via the Kafka consumer.";
    public static final Boolean CAMEL_SOURCE_KAFKA_COMPONENT_ALLOW_MANUAL_COMMIT_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ENABLE_CONF = "camel.component.kafka.autoCommitEnable";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ENABLE_DOC = "If true, periodically commit to ZooKeeper the offset of messages already fetched by the consumer. This committed offset will be used when the process fails as the position from which the new consumer will begin.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ENABLE_DEFAULT = "true";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_INTERVAL_MS_CONF = "camel.component.kafka.autoCommitIntervalMs";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_INTERVAL_MS_DOC = "The frequency in ms that the consumer offsets are committed to zookeeper.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_INTERVAL_MS_DEFAULT = "5000";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ON_STOP_CONF = "camel.component.kafka.autoCommitOnStop";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ON_STOP_DOC = "Whether to perform an explicit auto commit when the consumer stops to ensure the broker has a commit from the last consumed message. This requires the option autoCommitEnable is turned on. The possible values are: sync, async, or none. And sync is the default value. One of: [sync] [async] [none]";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ON_STOP_DEFAULT = "sync";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_OFFSET_RESET_CONF = "camel.component.kafka.autoOffsetReset";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_OFFSET_RESET_DOC = "What to do when there is no initial offset in ZooKeeper or if an offset is out of range: earliest : automatically reset the offset to the earliest offset latest : automatically reset the offset to the latest offset fail: throw exception to the consumer One of: [latest] [earliest] [none]";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_OFFSET_RESET_DEFAULT = "latest";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_BREAK_ON_FIRST_ERROR_CONF = "camel.component.kafka.breakOnFirstError";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_BREAK_ON_FIRST_ERROR_DOC = "This options controls what happens when a consumer is processing an exchange and it fails. If the option is false then the consumer continues to the next message and processes it. If the option is true then the consumer breaks out, and will seek back to offset of the message that caused a failure, and then re-attempt to process this message. However this can lead to endless processing of the same message if its bound to fail every time, eg a poison message. Therefore its recommended to deal with that for example by using Camel's error handler.";
    public static final Boolean CAMEL_SOURCE_KAFKA_COMPONENT_BREAK_ON_FIRST_ERROR_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_BRIDGE_ERROR_HANDLER_CONF = "camel.component.kafka.bridgeErrorHandler";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_BRIDGE_ERROR_HANDLER_DOC = "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.";
    public static final Boolean CAMEL_SOURCE_KAFKA_COMPONENT_BRIDGE_ERROR_HANDLER_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CHECK_CRCS_CONF = "camel.component.kafka.checkCrcs";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CHECK_CRCS_DOC = "Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CHECK_CRCS_DEFAULT = "true";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_REQUEST_TIMEOUT_MS_CONF = "camel.component.kafka.consumerRequestTimeoutMs";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_REQUEST_TIMEOUT_MS_DOC = "The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_REQUEST_TIMEOUT_MS_DEFAULT = "40000";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMERS_COUNT_CONF = "camel.component.kafka.consumersCount";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMERS_COUNT_DOC = "The number of consumers that connect to kafka server";
    public static final Integer CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMERS_COUNT_DEFAULT = 1;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_STREAMS_CONF = "camel.component.kafka.consumerStreams";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_STREAMS_DOC = "Number of concurrent consumers on the consumer";
    public static final Integer CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_STREAMS_DEFAULT = 10;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MAX_BYTES_CONF = "camel.component.kafka.fetchMaxBytes";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MAX_BYTES_DOC = "The maximum amount of data the server should return for a fetch request This is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that the consumer can make progress. The maximum message size accepted by the broker is defined via message.max.bytes (broker config) or max.message.bytes (topic config). Note that the consumer performs multiple fetches in parallel.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MAX_BYTES_DEFAULT = "52428800";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MIN_BYTES_CONF = "camel.component.kafka.fetchMinBytes";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MIN_BYTES_DOC = "The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MIN_BYTES_DEFAULT = "1";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_WAIT_MAX_MS_CONF = "camel.component.kafka.fetchWaitMaxMs";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_WAIT_MAX_MS_DOC = "The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy fetch.min.bytes";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_WAIT_MAX_MS_DEFAULT = "500";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_GROUP_ID_CONF = "camel.component.kafka.groupId";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_GROUP_ID_DOC = "A string that uniquely identifies the group of consumer processes to which this consumer belongs. By setting the same group id multiple processes indicate that they are all part of the same consumer group. This option is required for consumers.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_GROUP_ID_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_HEARTBEAT_INTERVAL_MS_CONF = "camel.component.kafka.heartbeatIntervalMs";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_HEARTBEAT_INTERVAL_MS_DOC = "The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. Heartbeats are used to ensure that the consumer's session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than session.timeout.ms, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_HEARTBEAT_INTERVAL_MS_DEFAULT = "3000";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_HEADER_DESERIALIZER_CONF = "camel.component.kafka.kafkaHeaderDeserializer";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_HEADER_DESERIALIZER_DOC = "To use a custom KafkaHeaderDeserializer to deserialize kafka headers values";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_HEADER_DESERIALIZER_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KEY_DESERIALIZER_CONF = "camel.component.kafka.keyDeserializer";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KEY_DESERIALIZER_DOC = "Deserializer class for key that implements the Deserializer interface.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KEY_DESERIALIZER_DEFAULT = "org.apache.kafka.common.serialization.StringDeserializer";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_MAX_PARTITION_FETCH_BYTES_CONF = "camel.component.kafka.maxPartitionFetchBytes";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_MAX_PARTITION_FETCH_BYTES_DOC = "The maximum amount of data per-partition the server will return. The maximum total memory used for a request will be #partitions max.partition.fetch.bytes. This size must be at least as large as the maximum message size the server allows or else it is possible for the producer to send messages larger than the consumer can fetch. If that happens, the consumer can get stuck trying to fetch a large message on a certain partition.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_MAX_PARTITION_FETCH_BYTES_DEFAULT = "1048576";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_INTERVAL_MS_CONF = "camel.component.kafka.maxPollIntervalMs";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_INTERVAL_MS_DOC = "The maximum delay between invocations of poll() when using consumer group management. This places an upper bound on the amount of time that the consumer can be idle before fetching more records. If poll() is not called before expiration of this timeout, then the consumer is considered failed and the group will rebalance in order to reassign the partitions to another member.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_INTERVAL_MS_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_RECORDS_CONF = "camel.component.kafka.maxPollRecords";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_RECORDS_DOC = "The maximum number of records returned in a single call to poll()";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_RECORDS_DEFAULT = "500";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_OFFSET_REPOSITORY_CONF = "camel.component.kafka.offsetRepository";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_OFFSET_REPOSITORY_DOC = "The offset repository to use in order to locally store the offset of each partition of the topic. Defining one will disable the autocommit.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_OFFSET_REPOSITORY_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_PARTITION_ASSIGNOR_CONF = "camel.component.kafka.partitionAssignor";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_PARTITION_ASSIGNOR_DOC = "The class name of the partition assignment strategy that the client will use to distribute partition ownership amongst consumer instances when group management is used";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_PARTITION_ASSIGNOR_DEFAULT = "org.apache.kafka.clients.consumer.RangeAssignor";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_POLL_TIMEOUT_MS_CONF = "camel.component.kafka.pollTimeoutMs";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_POLL_TIMEOUT_MS_DOC = "The timeout used when polling the KafkaConsumer.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_POLL_TIMEOUT_MS_DEFAULT = "5000";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SEEK_TO_CONF = "camel.component.kafka.seekTo";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SEEK_TO_DOC = "Set if KafkaConsumer will read from beginning or end on startup: beginning : read from beginning end : read from end This is replacing the earlier property seekToBeginning One of: [beginning] [end]";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SEEK_TO_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SESSION_TIMEOUT_MS_CONF = "camel.component.kafka.sessionTimeoutMs";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SESSION_TIMEOUT_MS_DOC = "The timeout used to detect failures when using Kafka's group management facilities.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SESSION_TIMEOUT_MS_DEFAULT = "10000";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SPECIFIC_AVRO_READER_CONF = "camel.component.kafka.specificAvroReader";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SPECIFIC_AVRO_READER_DOC = "This enables the use of a specific Avro reader for use with the Confluent Platform schema registry and the io.confluent.kafka.serializers.KafkaAvroDeserializer. This option is only available in the Confluent Platform (not standard Apache Kafka)";
    public static final Boolean CAMEL_SOURCE_KAFKA_COMPONENT_SPECIFIC_AVRO_READER_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_TOPIC_IS_PATTERN_CONF = "camel.component.kafka.topicIsPattern";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_TOPIC_IS_PATTERN_DOC = "Whether the topic is a pattern (regular expression). This can be used to subscribe to dynamic number of topics matching the pattern.";
    public static final Boolean CAMEL_SOURCE_KAFKA_COMPONENT_TOPIC_IS_PATTERN_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_VALUE_DESERIALIZER_CONF = "camel.component.kafka.valueDeserializer";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_VALUE_DESERIALIZER_DOC = "Deserializer class for value that implements the Deserializer interface.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_VALUE_DESERIALIZER_DEFAULT = "org.apache.kafka.common.serialization.StringDeserializer";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_MANUAL_COMMIT_FACTORY_CONF = "camel.component.kafka.kafkaManualCommitFactory";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_MANUAL_COMMIT_FACTORY_DOC = "Factory to use for creating KafkaManualCommit instances. This allows to plugin a custom factory to create custom KafkaManualCommit instances in case special logic is needed when doing manual commits that deviates from the default implementation that comes out of the box.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_MANUAL_COMMIT_FACTORY_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_BASIC_PROPERTY_BINDING_CONF = "camel.component.kafka.basicPropertyBinding";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_BASIC_PROPERTY_BINDING_DOC = "Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities";
    public static final Boolean CAMEL_SOURCE_KAFKA_COMPONENT_BASIC_PROPERTY_BINDING_DEFAULT = false;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SCHEMA_REGISTRY_URLCONF = "camel.component.kafka.schemaRegistryURL";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SCHEMA_REGISTRY_URLDOC = "URL of the Confluent Platform schema registry servers to use. The format is host1:port1,host2:port2. This is known as schema.registry.url in the Confluent Platform documentation. This option is only available in the Confluent Platform (not standard Apache Kafka)";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SCHEMA_REGISTRY_URLDEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_INTERCEPTOR_CLASSES_CONF = "camel.component.kafka.interceptorClasses";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_INTERCEPTOR_CLASSES_DOC = "Sets interceptors for producer or consumers. Producer interceptors have to be classes implementing org.apache.kafka.clients.producer.ProducerInterceptor Consumer interceptors have to be classes implementing org.apache.kafka.clients.consumer.ConsumerInterceptor Note that if you use Producer interceptor on a consumer it will throw a class cast exception in runtime";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_INTERCEPTOR_CLASSES_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_CONF = "camel.component.kafka.kerberosBeforeReloginMinTime";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_DOC = "Login thread sleep time between refresh attempts.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_DEFAULT = "60000";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_INIT_CMD_CONF = "camel.component.kafka.kerberosInitCmd";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_INIT_CMD_DOC = "Kerberos kinit command path. Default is /usr/bin/kinit";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_INIT_CMD_DEFAULT = "/usr/bin/kinit";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_CONF = "camel.component.kafka.kerberosPrincipalToLocalRules";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DOC = "A list of rules for mapping from principal names to short names (typically operating system usernames). The rules are evaluated in order and the first rule that matches a principal name is used to map it to a short name. Any later rules in the list are ignored. By default, principal names of the form {username}/{hostname}{REALM} are mapped to {username}. For more details on the format please see the security authorization and acls documentation.. Multiple values can be separated by comma";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DEFAULT = "DEFAULT";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_JITTER_CONF = "camel.component.kafka.kerberosRenewJitter";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_JITTER_DOC = "Percentage of random jitter added to the renewal time.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_JITTER_DEFAULT = "0.05";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_WINDOW_FACTOR_CONF = "camel.component.kafka.kerberosRenewWindowFactor";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_WINDOW_FACTOR_DOC = "Login thread will sleep until the specified window factor of time from last refresh to ticket's expiry has been reached, at which time it will try to renew the ticket.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_WINDOW_FACTOR_DEFAULT = "0.8";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SASL_JAAS_CONFIG_CONF = "camel.component.kafka.saslJaasConfig";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SASL_JAAS_CONFIG_DOC = "Expose the kafka sasl.jaas.config parameter Example: org.apache.kafka.common.security.plain.PlainLoginModule required username=USERNAME password=PASSWORD;";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SASL_JAAS_CONFIG_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SASL_KERBEROS_SERVICE_NAME_CONF = "camel.component.kafka.saslKerberosServiceName";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SASL_KERBEROS_SERVICE_NAME_DOC = "The Kerberos principal name that Kafka runs as. This can be defined either in Kafka's JAAS config or in Kafka's config.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SASL_KERBEROS_SERVICE_NAME_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SASL_MECHANISM_CONF = "camel.component.kafka.saslMechanism";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SASL_MECHANISM_DOC = "The Simple Authentication and Security Layer (SASL) Mechanism used. For the valid values see http://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SASL_MECHANISM_DEFAULT = "GSSAPI";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SECURITY_PROTOCOL_CONF = "camel.component.kafka.securityProtocol";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SECURITY_PROTOCOL_DOC = "Protocol used to communicate with brokers. SASL_PLAINTEXT, PLAINTEXT and SSL are supported";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SECURITY_PROTOCOL_DEFAULT = "PLAINTEXT";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CIPHER_SUITES_CONF = "camel.component.kafka.sslCipherSuites";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CIPHER_SUITES_DOC = "A list of cipher suites. This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol.By default all the available cipher suites are supported.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CIPHER_SUITES_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CONTEXT_PARAMETERS_CONF = "camel.component.kafka.sslContextParameters";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CONTEXT_PARAMETERS_DOC = "SSL configuration using a Camel SSLContextParameters object. If configured it's applied before the other SSL endpoint parameters. NOTE: Kafka only supports loading keystore from file locations, so prefix the location with file: in the KeyStoreParameters.resource option.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CONTEXT_PARAMETERS_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENABLED_PROTOCOLS_CONF = "camel.component.kafka.sslEnabledProtocols";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENABLED_PROTOCOLS_DOC = "The list of protocols enabled for SSL connections. TLSv1.2, TLSv1.1 and TLSv1 are enabled by default.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENABLED_PROTOCOLS_DEFAULT = "TLSv1.2";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENDPOINT_ALGORITHM_CONF = "camel.component.kafka.sslEndpointAlgorithm";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENDPOINT_ALGORITHM_DOC = "The endpoint identification algorithm to validate server hostname using server certificate.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENDPOINT_ALGORITHM_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYMANAGER_ALGORITHM_CONF = "camel.component.kafka.sslKeymanagerAlgorithm";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYMANAGER_ALGORITHM_DOC = "The algorithm used by key manager factory for SSL connections. Default value is the key manager factory algorithm configured for the Java Virtual Machine.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYMANAGER_ALGORITHM_DEFAULT = "SunX509";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYSTORE_TYPE_CONF = "camel.component.kafka.sslKeystoreType";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYSTORE_TYPE_DOC = "The file format of the key store file. This is optional for client. Default value is JKS";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYSTORE_TYPE_DEFAULT = "JKS";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROTOCOL_CONF = "camel.component.kafka.sslProtocol";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROTOCOL_DOC = "The SSL protocol used to generate the SSLContext. Default setting is TLS, which is fine for most cases. Allowed values in recent JVMs are TLS, TLSv1.1 and TLSv1.2. SSL, SSLv2 and SSLv3 may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROTOCOL_DEFAULT = "TLSv1.2";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROVIDER_CONF = "camel.component.kafka.sslProvider";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROVIDER_DOC = "The name of the security provider used for SSL connections. Default value is the default security provider of the JVM.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROVIDER_DEFAULT = null;
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTMANAGER_ALGORITHM_CONF = "camel.component.kafka.sslTrustmanagerAlgorithm";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTMANAGER_ALGORITHM_DOC = "The algorithm used by trust manager factory for SSL connections. Default value is the trust manager factory algorithm configured for the Java Virtual Machine.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTMANAGER_ALGORITHM_DEFAULT = "PKIX";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTSTORE_TYPE_CONF = "camel.component.kafka.sslTruststoreType";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTSTORE_TYPE_DOC = "The file format of the trust store file. Default value is JKS.";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTSTORE_TYPE_DEFAULT = "JKS";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_USE_GLOBAL_SSL_CONTEXT_PARAMETERS_CONF = "camel.component.kafka.useGlobalSslContextParameters";
    public static final String CAMEL_SOURCE_KAFKA_COMPONENT_USE_GLOBAL_SSL_CONTEXT_PARAMETERS_DOC = "Enable usage of global SSL context parameters.";
    public static final Boolean CAMEL_SOURCE_KAFKA_COMPONENT_USE_GLOBAL_SSL_CONTEXT_PARAMETERS_DEFAULT = false;

    public CamelKafkaSourceConnectorConfig(
            ConfigDef config,
            Map<String, String> parsedConfig) {
        super(config, parsedConfig);
    }

    public CamelKafkaSourceConnectorConfig(Map<String, String> parsedConfig) {
        this(conf(), parsedConfig);
    }

    public static ConfigDef conf() {
        ConfigDef conf = new ConfigDef(CamelSourceConnectorConfig.conf());
        conf.define(CAMEL_SOURCE_KAFKA_PATH_TOPIC_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_PATH_TOPIC_DEFAULT, ConfigDef.Importance.HIGH, CAMEL_SOURCE_KAFKA_PATH_TOPIC_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_ADDITIONAL_PROPERTIES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_ADDITIONAL_PROPERTIES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_ADDITIONAL_PROPERTIES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_BROKERS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_BROKERS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_BROKERS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_CLIENT_ID_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_CLIENT_ID_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_CLIENT_ID_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_HEADER_FILTER_STRATEGY_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_HEADER_FILTER_STRATEGY_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_HEADER_FILTER_STRATEGY_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_RECONNECT_BACKOFF_MAX_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_RECONNECT_BACKOFF_MAX_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_RECONNECT_BACKOFF_MAX_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SHUTDOWN_TIMEOUT_CONF, ConfigDef.Type.INT, CAMEL_SOURCE_KAFKA_ENDPOINT_SHUTDOWN_TIMEOUT_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SHUTDOWN_TIMEOUT_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_ALLOW_MANUAL_COMMIT_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_ENDPOINT_ALLOW_MANUAL_COMMIT_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_ALLOW_MANUAL_COMMIT_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ENABLE_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ENABLE_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ENABLE_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_INTERVAL_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_INTERVAL_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_INTERVAL_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ON_STOP_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ON_STOP_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_COMMIT_ON_STOP_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_OFFSET_RESET_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_OFFSET_RESET_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_AUTO_OFFSET_RESET_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_BREAK_ON_FIRST_ERROR_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_ENDPOINT_BREAK_ON_FIRST_ERROR_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_BREAK_ON_FIRST_ERROR_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_BRIDGE_ERROR_HANDLER_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_ENDPOINT_BRIDGE_ERROR_HANDLER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_BRIDGE_ERROR_HANDLER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_CHECK_CRCS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_CHECK_CRCS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_CHECK_CRCS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_REQUEST_TIMEOUT_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_REQUEST_TIMEOUT_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_REQUEST_TIMEOUT_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMERS_COUNT_CONF, ConfigDef.Type.INT, CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMERS_COUNT_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMERS_COUNT_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_STREAMS_CONF, ConfigDef.Type.INT, CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_STREAMS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_CONSUMER_STREAMS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MAX_BYTES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MAX_BYTES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MAX_BYTES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MIN_BYTES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MIN_BYTES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_MIN_BYTES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_WAIT_MAX_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_WAIT_MAX_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_FETCH_WAIT_MAX_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_GROUP_ID_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_GROUP_ID_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_GROUP_ID_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_HEARTBEAT_INTERVAL_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_HEARTBEAT_INTERVAL_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_HEARTBEAT_INTERVAL_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_KAFKA_HEADER_DESERIALIZER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_KAFKA_HEADER_DESERIALIZER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_KAFKA_HEADER_DESERIALIZER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_KEY_DESERIALIZER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_KEY_DESERIALIZER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_KEY_DESERIALIZER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_PARTITION_FETCH_BYTES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_PARTITION_FETCH_BYTES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_PARTITION_FETCH_BYTES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_INTERVAL_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_INTERVAL_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_INTERVAL_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_RECORDS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_RECORDS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_MAX_POLL_RECORDS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_OFFSET_REPOSITORY_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_OFFSET_REPOSITORY_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_OFFSET_REPOSITORY_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_PARTITION_ASSIGNOR_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_PARTITION_ASSIGNOR_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_PARTITION_ASSIGNOR_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_POLL_TIMEOUT_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_POLL_TIMEOUT_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_POLL_TIMEOUT_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SEEK_TO_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SEEK_TO_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SEEK_TO_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SESSION_TIMEOUT_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SESSION_TIMEOUT_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SESSION_TIMEOUT_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SPECIFIC_AVRO_READER_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_ENDPOINT_SPECIFIC_AVRO_READER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SPECIFIC_AVRO_READER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_TOPIC_IS_PATTERN_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_ENDPOINT_TOPIC_IS_PATTERN_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_TOPIC_IS_PATTERN_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_VALUE_DESERIALIZER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_VALUE_DESERIALIZER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_VALUE_DESERIALIZER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_EXCEPTION_HANDLER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_EXCEPTION_HANDLER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_EXCEPTION_HANDLER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_EXCHANGE_PATTERN_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_EXCHANGE_PATTERN_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_EXCHANGE_PATTERN_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_BASIC_PROPERTY_BINDING_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_ENDPOINT_BASIC_PROPERTY_BINDING_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_BASIC_PROPERTY_BINDING_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SYNCHRONOUS_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_ENDPOINT_SYNCHRONOUS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SYNCHRONOUS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SCHEMA_REGISTRY_URLCONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SCHEMA_REGISTRY_URLDEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SCHEMA_REGISTRY_URLDOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_INTERCEPTOR_CLASSES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_INTERCEPTOR_CLASSES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_INTERCEPTOR_CLASSES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_INIT_CMD_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_INIT_CMD_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_INIT_CMD_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_JITTER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_JITTER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_JITTER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_WINDOW_FACTOR_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_WINDOW_FACTOR_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_KERBEROS_RENEW_WINDOW_FACTOR_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_JAAS_CONFIG_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_JAAS_CONFIG_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_JAAS_CONFIG_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_KERBEROS_SERVICE_NAME_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_KERBEROS_SERVICE_NAME_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_KERBEROS_SERVICE_NAME_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_MECHANISM_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_MECHANISM_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SASL_MECHANISM_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SECURITY_PROTOCOL_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SECURITY_PROTOCOL_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SECURITY_PROTOCOL_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CIPHER_SUITES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CIPHER_SUITES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CIPHER_SUITES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CONTEXT_PARAMETERS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CONTEXT_PARAMETERS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_CONTEXT_PARAMETERS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENABLED_PROTOCOLS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENABLED_PROTOCOLS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENABLED_PROTOCOLS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENDPOINT_ALGORITHM_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENDPOINT_ALGORITHM_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_ENDPOINT_ALGORITHM_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYMANAGER_ALGORITHM_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYMANAGER_ALGORITHM_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYMANAGER_ALGORITHM_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYSTORE_TYPE_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYSTORE_TYPE_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_KEYSTORE_TYPE_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROTOCOL_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROTOCOL_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROTOCOL_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROVIDER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROVIDER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_PROVIDER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTMANAGER_ALGORITHM_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTMANAGER_ALGORITHM_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTMANAGER_ALGORITHM_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTSTORE_TYPE_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTSTORE_TYPE_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_ENDPOINT_SSL_TRUSTSTORE_TYPE_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_ADDITIONAL_PROPERTIES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_ADDITIONAL_PROPERTIES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_ADDITIONAL_PROPERTIES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_BROKERS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_BROKERS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_BROKERS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_CLIENT_ID_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_CLIENT_ID_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_CLIENT_ID_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_CONFIGURATION_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_CONFIGURATION_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_CONFIGURATION_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_HEADER_FILTER_STRATEGY_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_HEADER_FILTER_STRATEGY_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_HEADER_FILTER_STRATEGY_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_RECONNECT_BACKOFF_MAX_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_RECONNECT_BACKOFF_MAX_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_RECONNECT_BACKOFF_MAX_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SHUTDOWN_TIMEOUT_CONF, ConfigDef.Type.INT, CAMEL_SOURCE_KAFKA_COMPONENT_SHUTDOWN_TIMEOUT_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SHUTDOWN_TIMEOUT_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_ALLOW_MANUAL_COMMIT_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_COMPONENT_ALLOW_MANUAL_COMMIT_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_ALLOW_MANUAL_COMMIT_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ENABLE_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ENABLE_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ENABLE_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_INTERVAL_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_INTERVAL_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_INTERVAL_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ON_STOP_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ON_STOP_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_COMMIT_ON_STOP_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_OFFSET_RESET_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_OFFSET_RESET_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_AUTO_OFFSET_RESET_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_BREAK_ON_FIRST_ERROR_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_COMPONENT_BREAK_ON_FIRST_ERROR_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_BREAK_ON_FIRST_ERROR_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_BRIDGE_ERROR_HANDLER_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_COMPONENT_BRIDGE_ERROR_HANDLER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_BRIDGE_ERROR_HANDLER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_CHECK_CRCS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_CHECK_CRCS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_CHECK_CRCS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_REQUEST_TIMEOUT_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_REQUEST_TIMEOUT_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_REQUEST_TIMEOUT_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMERS_COUNT_CONF, ConfigDef.Type.INT, CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMERS_COUNT_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMERS_COUNT_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_STREAMS_CONF, ConfigDef.Type.INT, CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_STREAMS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_CONSUMER_STREAMS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MAX_BYTES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MAX_BYTES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MAX_BYTES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MIN_BYTES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MIN_BYTES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_MIN_BYTES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_WAIT_MAX_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_WAIT_MAX_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_FETCH_WAIT_MAX_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_GROUP_ID_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_GROUP_ID_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_GROUP_ID_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_HEARTBEAT_INTERVAL_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_HEARTBEAT_INTERVAL_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_HEARTBEAT_INTERVAL_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_HEADER_DESERIALIZER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_HEADER_DESERIALIZER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_HEADER_DESERIALIZER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_KEY_DESERIALIZER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_KEY_DESERIALIZER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_KEY_DESERIALIZER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_MAX_PARTITION_FETCH_BYTES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_MAX_PARTITION_FETCH_BYTES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_MAX_PARTITION_FETCH_BYTES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_INTERVAL_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_INTERVAL_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_INTERVAL_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_RECORDS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_RECORDS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_MAX_POLL_RECORDS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_OFFSET_REPOSITORY_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_OFFSET_REPOSITORY_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_OFFSET_REPOSITORY_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_PARTITION_ASSIGNOR_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_PARTITION_ASSIGNOR_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_PARTITION_ASSIGNOR_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_POLL_TIMEOUT_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_POLL_TIMEOUT_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_POLL_TIMEOUT_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SEEK_TO_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SEEK_TO_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SEEK_TO_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SESSION_TIMEOUT_MS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SESSION_TIMEOUT_MS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SESSION_TIMEOUT_MS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SPECIFIC_AVRO_READER_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_COMPONENT_SPECIFIC_AVRO_READER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SPECIFIC_AVRO_READER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_TOPIC_IS_PATTERN_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_COMPONENT_TOPIC_IS_PATTERN_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_TOPIC_IS_PATTERN_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_VALUE_DESERIALIZER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_VALUE_DESERIALIZER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_VALUE_DESERIALIZER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_MANUAL_COMMIT_FACTORY_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_MANUAL_COMMIT_FACTORY_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_KAFKA_MANUAL_COMMIT_FACTORY_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_BASIC_PROPERTY_BINDING_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_COMPONENT_BASIC_PROPERTY_BINDING_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_BASIC_PROPERTY_BINDING_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SCHEMA_REGISTRY_URLCONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SCHEMA_REGISTRY_URLDEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SCHEMA_REGISTRY_URLDOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_INTERCEPTOR_CLASSES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_INTERCEPTOR_CLASSES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_INTERCEPTOR_CLASSES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_BEFORE_RELOGIN_MIN_TIME_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_INIT_CMD_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_INIT_CMD_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_INIT_CMD_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_JITTER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_JITTER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_JITTER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_WINDOW_FACTOR_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_WINDOW_FACTOR_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_KERBEROS_RENEW_WINDOW_FACTOR_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SASL_JAAS_CONFIG_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SASL_JAAS_CONFIG_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SASL_JAAS_CONFIG_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SASL_KERBEROS_SERVICE_NAME_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SASL_KERBEROS_SERVICE_NAME_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SASL_KERBEROS_SERVICE_NAME_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SASL_MECHANISM_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SASL_MECHANISM_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SASL_MECHANISM_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SECURITY_PROTOCOL_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SECURITY_PROTOCOL_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SECURITY_PROTOCOL_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CIPHER_SUITES_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CIPHER_SUITES_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CIPHER_SUITES_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CONTEXT_PARAMETERS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CONTEXT_PARAMETERS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_CONTEXT_PARAMETERS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENABLED_PROTOCOLS_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENABLED_PROTOCOLS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENABLED_PROTOCOLS_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENDPOINT_ALGORITHM_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENDPOINT_ALGORITHM_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_ENDPOINT_ALGORITHM_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYMANAGER_ALGORITHM_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYMANAGER_ALGORITHM_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYMANAGER_ALGORITHM_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYSTORE_TYPE_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYSTORE_TYPE_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_KEYSTORE_TYPE_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROTOCOL_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROTOCOL_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROTOCOL_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROVIDER_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROVIDER_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_PROVIDER_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTMANAGER_ALGORITHM_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTMANAGER_ALGORITHM_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTMANAGER_ALGORITHM_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTSTORE_TYPE_CONF, ConfigDef.Type.STRING, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTSTORE_TYPE_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_SSL_TRUSTSTORE_TYPE_DOC);
        conf.define(CAMEL_SOURCE_KAFKA_COMPONENT_USE_GLOBAL_SSL_CONTEXT_PARAMETERS_CONF, ConfigDef.Type.BOOLEAN, CAMEL_SOURCE_KAFKA_COMPONENT_USE_GLOBAL_SSL_CONTEXT_PARAMETERS_DEFAULT, ConfigDef.Importance.MEDIUM, CAMEL_SOURCE_KAFKA_COMPONENT_USE_GLOBAL_SSL_CONTEXT_PARAMETERS_DOC);
        return conf;
    }
}